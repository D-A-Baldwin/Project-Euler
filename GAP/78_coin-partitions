# Find the least value of n for which p(n) is divisible by one million.

# Further down are initial naive attempts that proved too slow. The key
# is that I don't need the partitions themselves, just the number of 
# them. Therefore I can make use of the pentagonal number theorem.
# I also learned a fair bit about the difference between recursion 
# and iteration, my early attempts used a function that called itself
# which was way too slow.

IntegerPartitions_Pentagonal := function(n)
	local p, x, k, index_list, m;

	if n < 0 then
		return "Integer must be non-negative";
	elif n = 0 then
		return 1;
	elif n = 1 then
		return 1;
	fi;
	
	p := [1,1]; # the values for 0 and 1
	
	
	for m in [2..n] do
		p[m+1] := 0;
			
		# create list of pentagonal numbers
		x := 1;
		k := 1;
		index_list := [];
		while m - x >= 0 do
			Add(index_list, k);
			if k>0 then
				k := -k;
			else 
				k := -k + 1;
			fi;
			x := k*(3*k - 1)/2;
		od;
		
		for k in index_list do
			p[m+1] := p[m+1] + 
					(-1)^(k-1) * p[m - k*(3*k - 1)/2 + 1];
		od;
		if p[m+1] mod 10^6 = 0 then
			Print("Answer is: ", m);
			return;
		fi;
	od;
	
	return "Not found";
end;

#######
# 1: INITIAL NAIVE APPROACH. TOO SLOW TO WORK.
# p(n) here is simply the number of integer partitions of the integer n. So we can write a 
# simple recursive function to compute all the partitions of n.

IntegerPartitions := function(n)
  # Input is a non-negative integer.
  # Output is a list whose elements are lists of integers
  # corresponding to a partition of n.
  # e.g. IntegerPartitions(4) = [[1,1,1,1],[2,1,1],[2,2],[3,1],[4]]
  # Each element is of the form 
  # [i, a partition of n-i such that every element is <= i]
  # for all i from 1 to n.
	local partitions, sublist, i, part;
	
	if n < 0 then
		return "Integer must be non-negative";
	elif n = 0 then
		return [[]];
	elif n = 1 then
		return [[1]];
	fi;

	partitions := [];
	for i in [1..n] do
		part := IntegerPartitions(n-i);
		for j in part do
			sublist := [i];
			if ForAll(j, x -> x <= i) then
				Append(sublist, j);
				Add(partitions, sublist);
			fi;
		od;
	od;
	return partitions;
end;

#######
# 2: An attempt with a faster algorithm taken from
# "FAST ALGORITHMS FOR GENERATING INTEGER PARTITIONS"
# ANTOINE ZOGHBI and IVAN STOJMENOVIC
# Still much to slow, there is some other trick
# that I need to find.

IntegerPartitions_ZOGHBI := function(n)
	
	local x_list, m, h, r, t, partitions;
	
	x_list := List([1..n], i -> 1);
	x_list[1] := n;
	m := 1;
	h := 1;
	partitions := [[x_list[1]]];
	
	while x_list[1] <> 1 do
		if x_list[h] = 2 then	
			m := m + 1;
			x_list[h] := 1;
			h := h - 1;
		else
			r := x_list[h] - 1;
			t := m - h + 1;
			x_list[h] := r;
			
			while t >= r do
				h := h + 1;
				x_list[h] := r;
				t := t - r;
			od;
			
			if t = 0 then
				m := h;
			else
				m := h + 1;
				if t > 1 then
					h := h + 1; 	
					x_list[h] := t;
				fi;
			fi;
		fi;
		Add(partitions, x_list{[1..m]});
	od;
	return partitions;
end;
